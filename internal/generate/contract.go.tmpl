// Code generated by tzgen - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

{{- /*gotype: github.com/jeanschmitt/tzgen/internal/generate.Data*/ -}}

{{$meta := .Metadata}}

package {{$meta.Package}}

import (
	"context"
	"math/big"

	"blockwatch.cc/tzgo/codec"
	"blockwatch.cc/tzgo/micheline"
	"blockwatch.cc/tzgo/tezos"
	"github.com/jeanschmitt/tzgen/pkg/bind"
	"github.com/jeanschmitt/tzgen/pkg/builder"
)

{{$contract := struct .Contract.Name}}

{{with .Contract}}

{{$r := $meta.Receiver}}
{{$rc := printf "(%s *%s)" $r $contract}}

// {{$contract}}Interface is the interface to interact with {{$contract}} smart contract.
type {{$contract}}Interface interface {
	{{range .Entrypoints -}}
	{{method .Name}}(ctx context.Context, signer *bind.Signer{{range arglist .Args}}, {{.Name}} {{.Type}}{{end}}) (tezos.OpHash, error)
	{{end}}
}

// {{$contract}} is a handle to interact with a Tezos smart contract.
type {{$contract}} struct {
	*bind.Contract
}

// New{{$contract}} returns a handle to a deployed {{$contract}} smart contract.
func New{{$contract}}(address string, client *bind.Client) (*{{$contract}}, error) {
	contract, err := bind.NewContract(address, client)
	if err != nil {
		return nil, err
	}
	return &{{$contract}}{
		Contract: contract,
	}, nil
}

{{- /*}}
func {{$rc}} GetStorage(ctx context.Context) interface{} {
	panic("todo")
}
{{*/ -}}

{{if gt (len .Entrypoints) 0}}

// region Entrypoints

{{range .Entrypoints}}

// {{method .Name}} is a binding to the {{$contract}} smart contract's `{{.Name}}` entrypoint.
func {{$rc}} {{method .Name}}(ctx context.Context, signer *bind.Signer{{range arglist .Args}}, {{.Name}} {{.Type}}{{end}}) (tezos.OpHash, error) {
	return {{$r}}.Rpc.PreApplyAndInject(ctx, signer, &codec.Transaction{
		Destination: {{$r}}.Address,
		Parameters:  {{$r}}.{{method .Name}}Op({{range arglist .Args}}{{.Name}},{{end}}),
	})
}

{{end}}

// endregion

// region Entrypoint operation builders

{{range .Entrypoints}}

// {{method .Name}}Op builds the Operation parameters to interact with `{{.Name}}` entrypoint.
func {{$rc}} {{method .Name}}Op({{range arglist .Args}}{{.Name}} {{.Type}},{{end}}) *micheline.Parameters {
	return &micheline.Parameters{
		Entrypoint: "{{.Name}}",
		Value:      builder.New(){{range arglist .Args}}.{{.BuilderMethod}}({{.Name}}){{end}}.Finalize(),
	}
}

{{end}}

// endregion

{{end}}

{{end}}

{{if gt (len .Structs) 0}}

// region Records

{{range .Structs}}

{{$rcv := receiver .Name}}

// {{.Name}} is a record defined in the {{$contract}} smart contract.
type {{.Name}} struct {
	{{range fieldlist .Fields}}{{.Name}} {{.Type}};{{end}}
}

func ({{$rcv}} *{{.Name}}) ToPrim() micheline.Prim {
	return builder.New(){{range fieldlist .Fields}}.{{.BuilderMethod}}({{$rcv}}.{{.Name}}){{end}}.Finalize()
}

{{end}}

// endregion

{{end}}

{{if gt (len .Unions) 0}}

// region Unions

{{range .Unions}}

{{$rcv := receiver .Name}}
{{$leftIsPtr := isPtr (type .Left)}}
{{$leftIsNotPtr := not $leftIsPtr}}
{{$rightIsPtr := isPtr (type .Right)}}
{{$rightIsNotPtr := not $rightIsPtr}}

// {{.Name}} is a union that can be either a {{type .Left}} or a {{type .Right}}.
type {{.Name}} struct {
	l {{if $leftIsNotPtr}}*{{end}}{{type .Left}}
	r {{if $rightIsNotPtr}}*{{end}}{{type .Right}}
}

// NewLeft{{.Name}} returns a {{.Name}} of left ({{type .Left}}) type.
func NewLeft{{.Name}}(v {{type .Left}}) *{{.Name}} {
	{{- if $leftIsPtr}}
	if v == nil {
		panic("v cannot be nil")
	}
	{{end -}}
	return &{{.Name}}{l: {{if $leftIsNotPtr}}&{{end}}v}
}

// NewRight{{.Name}} returns a {{.Name}} of right ({{type .Right}}) type.
func NewRight{{.Name}}(v {{type .Right}}) *{{.Name}} {
	{{- if $rightIsPtr}}
	if v == nil {
		panic("v cannot be nil")
	}
	{{end -}}
	return &{{.Name}}{r: {{if $rightIsNotPtr}}&{{end}}v}
}

func ({{$rcv}} *{{.Name}}) ToPrim() micheline.Prim {
	if {{$rcv}}.l != nil {
		return builder.New().{{builderMethod .Left}}({{if $leftIsNotPtr}}*{{end}}{{$rcv}}.l).Finalize()
	}
	if {{$rcv}}.r != nil {
		return builder.New().{{builderMethod .Right}}({{if $rightIsNotPtr}}*{{end}}{{$rcv}}.r).Finalize()
	}
	panic("union is neither left nor right")
}

{{end}}

// endregion

{{end}}

// {{$contract}}Micheline is the input Micheline used to generate the binding.
const {{$contract}}Micheline = `{{.Contract.Micheline}}`

var (
	_ = big.NewInt
)
